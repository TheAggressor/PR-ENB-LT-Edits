//========================= V1.4 =============================//
//    ___ _            _             _      _    _            //
//   / __| |_  __ _ __| |___ _ _    /_\  __| |__| |___ _ _    //
//   \__ \ ' \/ _` / _` / -_) '_|  / _ \/ _` / _` / _ \ ' \   //
//   |___/_||_\__,_\__,_\___|_|   /_/ \_\__,_\__,_\___/_||_|  //
//                                                            //
//============================================================//
// Shader Addon by Adyss                                      //
// Id like to say thanks to some helping hands. Without some  //
// of them this wouln't exist.                                //
// TreyM: Helping me with general code understanding          //
// The Sandvich Maker: For his super neat tools and advice    //
// LonelyKitsune: Help me with to get the sunposition         //
// Also this uses code bits from: Kingeric1992 and Luluco250  //
//============================================================//

//==========//
// Textures //
//==========//
Texture2D			TextureOriginal;     // color R16B16G16A16 64 bit hdr format
Texture2D			TextureColor;        // color which is output of previous technique (except when drawed to temporary render target), R16B16G16A16 64 bit hdr format
Texture2D			TextureDepth;        // scene depth R32F 32 bit hdr format
Texture2D			TextureJitter;       // blue noise
Texture2D			TextureMask;         // alpha channel is mask for skinned objects (less than 1) and amount of sss
Texture2D           TextureNormal;       // Normal maps i guess. Also alpha seems to only effect a few selected objects

Texture2D			RenderTargetRGBA32;  // R8G8B8A8 32 bit ldr format
Texture2D			RenderTargetRGBA64;  // R16B16G16A16 64 bit ldr format
Texture2D			RenderTargetRGBA64F; // R16B16G16A16F 64 bit hdr format
Texture2D			RenderTargetR16F;    // R16F 16 bit hdr format with red channel only
Texture2D			RenderTargetR32F;    // R32F 32 bit hdr format with red channel only
Texture2D			RenderTargetRGB32F;  // 32 bit hdr format without alpha

// Include Needes Values
#include "Include/Helper.fxh"
#include "Include/ReforgedUI.fxh"
#include "Include/Conversions.fxh"
#include "Include/Blendmodes.fxh"

//=====//
// GUI //
//=====//
UI_MESSAGE(w1,                  "Shader Addon V1.4")
UI_MESSAGE(w2,                  "by Adyss")
UI_WHITESPACE(1)
#define UI_CATEGORY Godrays
#define UI_PREFIX_MODE PREFIX
UI_SEPARATOR
UI_BOOL(ToggleRays,             "Toggle",                         false)
UI_INT(Samples,                 "Samples",                        2.0, 10.0, 2.0)
UI_FLOAT3_TODE_DNI(SunColor,             "Color",                 0.85, 0.73, 0.62)
UI_FLOAT(RayPower,              "Power",                          0.0, 7.0, 3.0)
UI_FLOAT(RayTight,              "Tightness",                      0.5, 3.0, 1.0)
UI_FLOAT(RayLength,             "Length",                         0.2, 5.0, 1.0)
UI_BOOL(Use_BoxBlur,            "Enable Box Blur",                false)
UI_FLOAT(BBRadius,              "Box Blur Radius",                0.5, 10.0, 1.0)
UI_WHITESPACE(2)
#define UI_CATEGORY Skin
UI_SEPARATOR
UI_BOOL(ToggleSkin,             "Toggle",                         false)
UI_FLOAT_TODE_DNI(SkinGamma,             "Gamma",                 0.5, 3.0, 1.0)
UI_FLOAT_TODE_DNI(SkinExposure,          "Exposure",             -2.0, 2.0, 0.0)
UI_FLOAT3(SkinTint,             "Tint",                           0.55, 0.43, 0.42)
UI_FLOAT(SkinTintStrength,      "Tint Power",                     0.0, 1.0, 0.0)
UI_FLOAT(SkinHue,               "Hue",                            0.0, 6.0, 0.0)
UI_FLOAT(HueOpacity,            "Hue opacity",                    0.0, 1.0, 0.0)
UI_WHITESPACE(3)
#define UI_CATEGORY Sky
UI_SEPARATOR
UI_BOOL(ToggleSky,              "Toggle",                         false)
UI_FLOAT_TODE_DNI(SkyGamma,              "Gamma",                 0.5, 3.0, 1.0)
UI_FLOAT_TODE_DNI(SkySaturation,         "Saturation",            0.0, 2.0, 1.0)
UI_FLOAT3(SkyTint,              "Tint",                           0.55, 0.43, 0.42)
UI_FLOAT(SkyTintStrength,       "Tint Power",                     0.0, 1.0, 0.0)
UI_WHITESPACE(4)
#define UI_CATEGORY FakeHDR
UI_SEPARATOR
UI_BOOL(ToggleHDR,              "Toggle",                         false)
UI_FLOAT_DNI(fHDR,               "Amount",                        0.0, 1.0, 0.0)


//===========//
// Functions //
//===========//
float2 getSun()
{
    float3 Sundir       = SunDirection.xyz / SunDirection.w;
    float2 Suncoord     = Sundir.xy / Sundir.z;
           Suncoord     = Suncoord * float2(0.48, ScreenSize.z * 0.48) + 0.5;
           Suncoord.y   = 1.0 - Suncoord.y;
    return Suncoord;
}

/* This code was automatically generated by gaussianGenerator.py
   Number of filter taps per pass: 20
   Number of texture samples per pass: 11 */

static const float gaussianWeights[6] = { 0.161180738153, 0.265682535417, 0.121771162066, 0.0286520381333, 0.00316680421473, 0.000137091091547 };
static const float gaussianOffsets[6] = { 0.0, 1.44, 3.36, 5.28, 7.2, 9.12 };
static const int gaussianLoopLength   = 6;

float4 ApplyToSkin(float4 SkinColor, float2 coord)
{
    return lerp(SkinColor, TextureColor.Sample(LinearSampler, coord), TextureMask.Sample(LinearSampler, coord).w);
}

float4 SkinColorEdit(float4 Color)
{
    if (!ToggleSkin)
    return Color;
    Color      = pow(Color, SkinGamma);
    Color      = ldexp(Color, SkinExposure);
    Color.rgb  = lerp(Color, Color * SkinTint * 2.55, SkinTintStrength);
    float3 hsv = RGBtoHSV(Color.rgb);
    hsv.x     += SkinHue;
    Color.rgb  = lerp(Color, HSVtoRGB(hsv), HueOpacity);
    return       Color;
}

float3 BoxBlur(Texture2D inputTex, float2 coord, float2 ps)
{
	return (inputTex.Sample(LinearSampler, coord - ps * 0.5).rgb +
			inputTex.Sample(LinearSampler, coord + ps * 0.5).rgb +
			inputTex.Sample(LinearSampler, coord + float2(-ps.x, ps.y) * 0.5).rgb +
			inputTex.Sample(LinearSampler, coord + float2( ps.x,-ps.y) * 0.5).rgb) * 0.25;
}

// Golden Ratio
static const float gr = (1.0 + sqrt(5.0)) * 0.5;

//===============//
// Pixel Shaders //
//===============//
float3	PS_SkyMask(VS_OUTPUT IN) : SV_Target
{
    float  Mask    = TextureNormal.Sample(PointSampler, IN.txcoord.xy).w * GetLinearizedDepth(IN.txcoord.xy);
           Mask    = floor(Mask);
    float3 Color   = TextureColor.Sample(PointSampler, IN.txcoord.xy) * Mask;
    return Color;
}

float3	PS_DrawRays(VS_OUTPUT IN, float4 v0 : SV_Position0) : SV_Target
{
    if (!ToggleRays) discard;
    float2 coord        = IN.txcoord.xy;
    float  Rays         = 0;
    float2 Sunpos       = (coord - getSun()) * ((1.0 / Samples) * RayLength);
    float  Jitter       = TextureJitter.Load(int3(v0.xy % 16, 0)); // Thanks Sandvich

    for(int i = 1; i < Samples; i++)
    {
               Jitter         = frac(Jitter + gr * i);
        float2 Offset         = lerp(coord, coord - Sunpos, Jitter);
               Rays          += TextureColor.Sample(LinearSampler, Offset);
    }

    Rays /= Samples;  // Normalize

    return Rays;
}

float3	PS_RayBlurH(VS_OUTPUT IN) : SV_Target
{
    if (!ToggleRays) discard;
    float2 coord   = IN.txcoord.xy;
    float3 Blur    = TextureColor.Sample(LinearSampler, coord) * gaussianWeights[0];

    for (int i = 1; i < gaussianLoopLength; i++)
    {
        Blur += TextureColor.Sample(LinearSampler, coord + float2(gaussianOffsets[i], 0.0) * PixelSize) * gaussianWeights[i];
        Blur += TextureColor.Sample(LinearSampler, coord - float2(gaussianOffsets[i], 0.0) * PixelSize) * gaussianWeights[i];
    }

    return Blur;
}

float3	PS_RayBlurV(VS_OUTPUT IN) : SV_Target
{
    if (!ToggleRays) discard;

    float2 coord   = IN.txcoord.xy;
    float3 Blur    = TextureColor.Sample(LinearSampler, coord) * gaussianWeights[0];

    for (int i = 1; i < gaussianLoopLength; i++)
    {
        Blur += TextureColor.Sample(LinearSampler, coord + float2(0.0, gaussianOffsets[i]) * PixelSize) * gaussianWeights[i];
        Blur += TextureColor.Sample(LinearSampler, coord - float2(0.0, gaussianOffsets[i]) * PixelSize) * gaussianWeights[i];
    }

    return Blur;
}

float3	PS_RaysCombine(VS_OUTPUT IN) : SV_Target
{
    float3 Rays;

           if (!Use_BoxBlur)
           Rays          = TextureColor.Sample(LinearSampler, IN.txcoord.xy);

           if (Use_BoxBlur)
           Rays          = BoxBlur(TextureColor, IN.txcoord.xy, PixelSize * BBRadius);

           Rays         *= SunColor;
           Rays          = pow(Rays, RayTight); // Makes them look a bit better but not on higher values
    float3 Color         = TextureOriginal.Sample(PointSampler, IN.txcoord.xy);

    float2 Sun           = getSun();
    float2 Center        = float2(0.5, 0.5);
    float  Offcenter     = distance(Sun, Center);
    float  Sunvisibility = lerp(RayPower, 0, Offcenter);

           if (Sunvisibility > 0.01 && EInteriorFactor < 1.0 && ToggleRays > 0.99)
           Color        = lerp(Color, lerp(Color, Color + Rays, ENightDayFactor), Sunvisibility);
    return Color;
}

float4	PS_Skin(VS_OUTPUT IN) : SV_Target
{
    return ApplyToSkin(SkinColorEdit(TextureColor.Sample(LinearSampler, IN.txcoord.xy)), IN.txcoord.xy);
}

float3	PS_Tone(VS_OUTPUT IN) : SV_Target
{
    // Get Needed Values
    float2 coord        = IN.txcoord.xy;
    float3 Color        = TextureColor.Sample(PointSampler, coord);
    float4 Normals      = TextureNormal.Sample(PointSampler, coord);
    float  Mask         = Normals.w * GetLinearizedDepth(coord);
           Mask         = floor(Mask);

    // Find ground and sky
    float3 Sky          = Color * Mask;
           Color        = lerp(Color, 0.0, Mask);

    // HDR toneing from ansel but a bit more... freaky
    if (ToggleHDR) {
    float3 Ambient      = TextureMask.Sample(PointSampler, coord);
    float  NewLuma      = GetLuma((Color + Ambient) * 0.5, Rec709);
    float  OrgiLuma     = GetLuma(Color, Rec709);
    float  sqrtLum 	    = sqrt(NewLuma);
    float  HDRToning    = sqrtLum * lerp(sqrtLum * (2 * NewLuma * OrgiLuma - NewLuma - 2 * OrgiLuma + 2.0), (2 * sqrtLum * OrgiLuma - 2 * OrgiLuma + 1), OrgiLuma > 0.5); // a bit stolen from Ansel XD
           Color        = Color / (NewLuma+1e-6) * lerp(NewLuma, HDRToning, fHDR); }

    // Adjust Sky
    if (ToggleSky) {
           Sky          = pow(Sky, SkyGamma);
           Sky          = lerp(GetLuma(Sky, Rec709), Sky , SkySaturation);
           Sky          = lerp(Sky, Sky * SkyTint * 2.55, SkyTintStrength); }

    float3 Image        = lerp(Color, Sky, Mask); // Combine them
    return Image;
}



// TECHNIQUES
technique11 pre <string UIName="Shader Addon";>
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_SkyMask()));
    }
}

technique11 pre1
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_DrawRays()));
    }
}

technique11 pre2
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_DrawRays()));
    }
}

technique11 pre3
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_DrawRays()));
    }
}

technique11 pre4
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_RayBlurH()));
    }
}

technique11 pre5
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_RayBlurV()));
    }
}

technique11 pre6
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_RaysCombine()));
    }
}

technique11 pre7
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_Skin()));
    }
}

technique11 pre8
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_5_0, VS_Draw()));
        SetPixelShader (CompileShader(ps_5_0, PS_Tone()));
    }
}
